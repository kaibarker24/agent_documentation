{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Setting up a scene: When in doubt, check the \"Terrace\" scene for reference on how to do things. When importing the environment, make sure all meshes are given Colliders and set to the tag that applies (\"Floor\" to the floor, \"Wall\" to the walls etc.) Drop in a player (or smart agent) prefab Give that prefab its Isovist (see below) Hit play on the scene Player and Smart Agent A smart agent is an agent that autonomously navigates an environment. A Player is a smart agent (subclass) that also has a mode that allows it to be manually controlled. Press \"k\" to toggle this mode. Scriptable objects are used for the isovists for each agent. If you want to create a new agent it must have a UNIQUE isovist object. You can create new scriptable objects at runtime like ScriptableObject.CreateInstance<Isovist>() and calling agent.GetComponent<FieldOfView>.SetIsovist(isovist) to make sure the agent gets that isovist. If you are placing a player or agent in the scene, you must give it an isovist by first creating one in the resource window (Assets folder) in Unity, right click > Create > Isovist . Then, drag the isovist into the FieldOfView component in the prefab. Generating Signage Signage is generated via the SignManager script. Make an empty in the scene, make sure it is at position 0, 0, 0 and rotation 0, 0, 0, and then attach a \"SignManager\" component. Give the sign manager a prefab (model of sign, one is provided), a layout in the form of a json, and a direction prefab (provided as a prefab titled \"Directions\"). Then click \"Generate Signs\" in the inspector. This will generate all the signs from the json. Generating Visibility Graph Similar to signage, create an empty and attach the \"WorldGridContainer\" component. Then you must make a scriptable object that contains the settings for the graph. In the resource window (Assets folder) in Unity, right click > Create > World Grid . Name it whatever, mess with the settings (see \"Terrace\" scriptable object in the ScriptableObjects folder for reference), and then add it to the WorldGridContainer you created earlier. Then click the \"Generate Heatmap\" button in the inspector to generate the graph (this may take a while). Path Viewing Paths can be generated from agents (see CrowdAgentSpawner as example). If the paths are exported as .csv, make an empty in the scene and give it an AgentLineDrawer component. Select all paths in the resource window (shift + click) and drag all of them too the Files field in the inspector. Adjust the settings and click \"Visualize Paths\" to see the paths. To clear the list, set the size of Files to 0. Running a task Grab player manually to the start position Enter name of destination in dest field in SmartAgentController component in the inspector Attach the Door Gameobject corresponding to the destination Play and press k to start the simulation (Follow the agent's state from the StateMachine component of the Player ) Room numbers The room numbers form should look like the following: FXL_D_N , where * F (optional) = Floor letter * X (required) = Room number. * L (optional) = Room letter.(E.g: T411A, T411B, T411C, ...) * D (optional) = Door number if a room has multiple doors. (E.g: T114_1, T114_2, ...) * N (optional) = Name of the room. (E.g: T116A_cafe) Saving trajectory Turn on PathWriter script under Player . This will save the X,Y,Z coordinates and Uncertainty value in a csv file. Enter the path to save this file in the csv_path variable. Generating graph matrix Make an empty in the scene Attach a GraphGeneratorContainer script to it Attach a GraphGenerator scriptable object to the GraphGeneratorContainer . Make sure to assign the right path of the trajectory to the trajectoryData variable in GraphGenerator . This expects a cvs file with the same format as written by PathWriter . Click Generate Graph . Matrix will be saved under Assets/Data/Agents_Trajectory/graph.csv Visualizing navigation graph Run application Check DrawLines from inspector under the NavigationalGraph script in decisionpoint GameObject Switch to Scene tab view to visualize the graph. Make sure Gizmos visibility is activated Visualizing trajectory heatmap Make an empty in the scene. Make sure it has position and rotation (0, 0, 0) Attach WorldGridContainer script to it Attach PathVisualizer scriptable object to the World Grid variable in the inspector. Make sure to assign the right path of the trajectory to the pathData variable in PathVisualizer . This expects a cvs file with the same format as written by PathWriter . n.b To visualize participants trajectory, check the participants variable under PathVisualizer and set the correct file path to pathData . Click Generate Heatmap . This will create children objects and assign them the right colors Adding new floors 1. Floor Add new floor model to the scene. Set all wall objects to Layer to Wall and add Mesh Collider component. 2. Stairs Take a look at the children of the GameObject Stairs in the main tree under Terrace_Main scene: * Stairs elements (stairs and platform) connect the two floors * Each element (stairs and platform) has to be set to Walkable under Navigation > Object > Navigation Static * Each stairs have their own signs named after and placed in the corresponding floor (E.g: -1, 0, 1, ...) * Each stairs sign has Layer set to Stairs * Access to stairs are blocked by doors called after the corresponding floor (E.g: door_-1, door_0, ...) * Each door has Layer set to Wall . This prevents agent to change floors while exploring with no intention of changing floors 3. Signs Add SignManager GameObject to the floor model and attach SignManager script to it Create a scriptable object under ScriptableObjects/SignLayout, attach SignLayout script and the corresponding json file Attach Sign prefab, SignLayout scriptable object and Directions prefab to the SignManager script 4. Doors Add doors to the different rooms with names as mentioned in the Room Numbers section in the Readme file. Set Tag to Door and attach script Door . 5. Decision Nodes Add decisionpoint GameObject to the floor model and attach NavigationalGraph script to it Manually add decision nodes and their possible directions as children. Take a look at the decision nodes implemented in the Terrace_Main scene in floor T, G and 1. Attach DecisionPoint script to each decision node. Manually set id Decision nodes should not overlap. Direction subnodes should be outside of the corresponding decision node. Simulation Code The simulation is mainly managed by the StateMachine.cs and SmartAgentController.cs scripts. Agent Spawning Script AgentSpawner.cs has a list of agents to spawn agents sequentially: partsList . Each element in the list represents an agent and its parameters, saved as a struct called PartInfo . 1. To activate agent spawning, create a gameobject in the scene and add the AgentSpawner.cs . Deactivate any SmartAgent gameobject in the scene if activated 2. Enter the list of agents parameters in the fillPartsList() method. Common parameters like the uncertainty coefficients are set in the prefab Spawned Agent found in the prefabs folder 3. Assign the prefab SpawnedAgent to the variable Player in the script 4. Enter the spawning position and the destination name and assign the destination door gameobject. 5. Run the program Commands For MkDocs mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. For Agent Project Ctrl + K, Ctrl + C (comment) , Ctrl + U (uncomment) Ctrl + K, Ctrl + 0 - collapse all functions Ctrl + K, Ctrl + J - unfold all functions Agent Function","title":"Home"},{"location":"#overview","text":"","title":"Overview"},{"location":"#setting-up-a-scene","text":"When in doubt, check the \"Terrace\" scene for reference on how to do things. When importing the environment, make sure all meshes are given Colliders and set to the tag that applies (\"Floor\" to the floor, \"Wall\" to the walls etc.) Drop in a player (or smart agent) prefab Give that prefab its Isovist (see below) Hit play on the scene","title":"Setting up a scene:"},{"location":"#player-and-smart-agent","text":"A smart agent is an agent that autonomously navigates an environment. A Player is a smart agent (subclass) that also has a mode that allows it to be manually controlled. Press \"k\" to toggle this mode. Scriptable objects are used for the isovists for each agent. If you want to create a new agent it must have a UNIQUE isovist object. You can create new scriptable objects at runtime like ScriptableObject.CreateInstance<Isovist>() and calling agent.GetComponent<FieldOfView>.SetIsovist(isovist) to make sure the agent gets that isovist. If you are placing a player or agent in the scene, you must give it an isovist by first creating one in the resource window (Assets folder) in Unity, right click > Create > Isovist . Then, drag the isovist into the FieldOfView component in the prefab.","title":"Player and Smart Agent"},{"location":"#generating-signage","text":"Signage is generated via the SignManager script. Make an empty in the scene, make sure it is at position 0, 0, 0 and rotation 0, 0, 0, and then attach a \"SignManager\" component. Give the sign manager a prefab (model of sign, one is provided), a layout in the form of a json, and a direction prefab (provided as a prefab titled \"Directions\"). Then click \"Generate Signs\" in the inspector. This will generate all the signs from the json.","title":"Generating Signage"},{"location":"#generating-visibility-graph","text":"Similar to signage, create an empty and attach the \"WorldGridContainer\" component. Then you must make a scriptable object that contains the settings for the graph. In the resource window (Assets folder) in Unity, right click > Create > World Grid . Name it whatever, mess with the settings (see \"Terrace\" scriptable object in the ScriptableObjects folder for reference), and then add it to the WorldGridContainer you created earlier. Then click the \"Generate Heatmap\" button in the inspector to generate the graph (this may take a while).","title":"Generating Visibility Graph"},{"location":"#path-viewing","text":"Paths can be generated from agents (see CrowdAgentSpawner as example). If the paths are exported as .csv, make an empty in the scene and give it an AgentLineDrawer component. Select all paths in the resource window (shift + click) and drag all of them too the Files field in the inspector. Adjust the settings and click \"Visualize Paths\" to see the paths. To clear the list, set the size of Files to 0.","title":"Path Viewing"},{"location":"#running-a-task","text":"Grab player manually to the start position Enter name of destination in dest field in SmartAgentController component in the inspector Attach the Door Gameobject corresponding to the destination Play and press k to start the simulation (Follow the agent's state from the StateMachine component of the Player )","title":"Running a task"},{"location":"#room-numbers","text":"The room numbers form should look like the following: FXL_D_N , where * F (optional) = Floor letter * X (required) = Room number. * L (optional) = Room letter.(E.g: T411A, T411B, T411C, ...) * D (optional) = Door number if a room has multiple doors. (E.g: T114_1, T114_2, ...) * N (optional) = Name of the room. (E.g: T116A_cafe)","title":"Room numbers"},{"location":"#saving-trajectory","text":"Turn on PathWriter script under Player . This will save the X,Y,Z coordinates and Uncertainty value in a csv file. Enter the path to save this file in the csv_path variable.","title":"Saving trajectory"},{"location":"#generating-graph-matrix","text":"Make an empty in the scene Attach a GraphGeneratorContainer script to it Attach a GraphGenerator scriptable object to the GraphGeneratorContainer . Make sure to assign the right path of the trajectory to the trajectoryData variable in GraphGenerator . This expects a cvs file with the same format as written by PathWriter . Click Generate Graph . Matrix will be saved under Assets/Data/Agents_Trajectory/graph.csv","title":"Generating graph matrix"},{"location":"#visualizing-navigation-graph","text":"Run application Check DrawLines from inspector under the NavigationalGraph script in decisionpoint GameObject Switch to Scene tab view to visualize the graph. Make sure Gizmos visibility is activated","title":"Visualizing navigation graph"},{"location":"#visualizing-trajectory-heatmap","text":"Make an empty in the scene. Make sure it has position and rotation (0, 0, 0) Attach WorldGridContainer script to it Attach PathVisualizer scriptable object to the World Grid variable in the inspector. Make sure to assign the right path of the trajectory to the pathData variable in PathVisualizer . This expects a cvs file with the same format as written by PathWriter . n.b To visualize participants trajectory, check the participants variable under PathVisualizer and set the correct file path to pathData . Click Generate Heatmap . This will create children objects and assign them the right colors","title":"Visualizing trajectory heatmap"},{"location":"#adding-new-floors","text":"","title":"Adding new floors"},{"location":"#1-floor","text":"Add new floor model to the scene. Set all wall objects to Layer to Wall and add Mesh Collider component.","title":"1. Floor"},{"location":"#2-stairs","text":"Take a look at the children of the GameObject Stairs in the main tree under Terrace_Main scene: * Stairs elements (stairs and platform) connect the two floors * Each element (stairs and platform) has to be set to Walkable under Navigation > Object > Navigation Static * Each stairs have their own signs named after and placed in the corresponding floor (E.g: -1, 0, 1, ...) * Each stairs sign has Layer set to Stairs * Access to stairs are blocked by doors called after the corresponding floor (E.g: door_-1, door_0, ...) * Each door has Layer set to Wall . This prevents agent to change floors while exploring with no intention of changing floors","title":"2. Stairs"},{"location":"#3-signs","text":"Add SignManager GameObject to the floor model and attach SignManager script to it Create a scriptable object under ScriptableObjects/SignLayout, attach SignLayout script and the corresponding json file Attach Sign prefab, SignLayout scriptable object and Directions prefab to the SignManager script","title":"3. Signs"},{"location":"#4-doors","text":"Add doors to the different rooms with names as mentioned in the Room Numbers section in the Readme file. Set Tag to Door and attach script Door .","title":"4. Doors"},{"location":"#5-decision-nodes","text":"Add decisionpoint GameObject to the floor model and attach NavigationalGraph script to it Manually add decision nodes and their possible directions as children. Take a look at the decision nodes implemented in the Terrace_Main scene in floor T, G and 1. Attach DecisionPoint script to each decision node. Manually set id Decision nodes should not overlap. Direction subnodes should be outside of the corresponding decision node.","title":"5. Decision Nodes"},{"location":"#simulation-code","text":"The simulation is mainly managed by the StateMachine.cs and SmartAgentController.cs scripts.","title":"Simulation Code"},{"location":"#agent-spawning","text":"Script AgentSpawner.cs has a list of agents to spawn agents sequentially: partsList . Each element in the list represents an agent and its parameters, saved as a struct called PartInfo . 1. To activate agent spawning, create a gameobject in the scene and add the AgentSpawner.cs . Deactivate any SmartAgent gameobject in the scene if activated 2. Enter the list of agents parameters in the fillPartsList() method. Common parameters like the uncertainty coefficients are set in the prefab Spawned Agent found in the prefabs folder 3. Assign the prefab SpawnedAgent to the variable Player in the script 4. Enter the spawning position and the destination name and assign the destination door gameobject. 5. Run the program","title":"Agent Spawning"},{"location":"#commands","text":"","title":"Commands"},{"location":"#for-mkdocs","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"For MkDocs"},{"location":"#for-agent-project","text":"Ctrl + K, Ctrl + C (comment) , Ctrl + U (uncomment) Ctrl + K, Ctrl + 0 - collapse all functions Ctrl + K, Ctrl + J - unfold all functions","title":"For Agent Project"},{"location":"#agent-function","text":"","title":"Agent Function"},{"location":"crowd-control/","text":"","title":"Crowd Agent Control"},{"location":"decision-points/","text":"","title":"Decision Making Points"},{"location":"detectables/","text":"","title":"Detectables"},{"location":"high-level-decisions/","text":"","title":"High Level Decision-Making Control"},{"location":"logfiles/","text":"","title":"Log Files"},{"location":"movements/","text":"Function Determines the target of the movement and the movement speed of the agent. MoveTo.cs Initialize() Initializes an Agent object and sets the movement speed using the parameter speed . An initialized agent is not pathfinding or moving by default. public void Initialize(float speed) { agent = GetComponent<NavMeshAgent>(); agent.avoidancePriority = Random.Range(30, 60); agent.speed = speed; Pathfinding = false; } Start() Calls initializer and sets the movement speed of the Agent. private void Start() { Initialize(1.25f); } SetTarget() Sets the target goal that the Agent will move to. Goal object is set through parameter goal and the Agent destination is mapped to the position of the goal object. The Agent then transitions to an active pathfinding state and will begin to move. The stairs parameter denotes if there are any stairs in the environment, and therefore dictates multi-level movement for the Update() function. public void SetTarget(Transform goal, bool stairs) { this.goal = goal; agent.destination = goal.position; agent.isStopped = false; Pathfinding = true; climbing = stairs; } Update() Checks if the target position is reached while the Agent is in an active pathfinding state. Using the x,z coordinates of the goal position and the agent position, we calculate the distance between the two objects. If the distance is less than 0.5 units, we stop the agent's movements and take it out of its active pathfinding state. If there is a multi-level environment as specified in SetTarget(), we incorporate the y value into the distance calculation. With this calculation, if the distance is less than 0.7 units we cease the agent's movements and take it out of its active pathfinding state. private void Update() { if (Pathfinding) { var g = goal.position; var t = transform.position; if (climbing) { var temp = Vector3.Distance(new Vector3(g.x, g.y, g.z), new Vector3(t.x, t.y, t.z)); if (Vector3.Distance(new Vector3(g.x, g.y, g.z), new Vector3(t.x, t.y, t.z)) < 0.7f) { agent.isStopped = true; Pathfinding = false; } } else { if (Vector3.Distance(new Vector3(g.x, 0, g.z), new Vector3(t.x, 0, t.z)) < 0.5f) { agent.isStopped = true; Pathfinding = false; } } } } abort() Stops the Agent and pauses pathfinding efforts. public void abort() { agent.isStopped = true; Pathfinding = false; }","title":"Movements"},{"location":"movements/#function","text":"Determines the target of the movement and the movement speed of the agent.","title":"Function"},{"location":"movements/#movetocs","text":"","title":"MoveTo.cs"},{"location":"movements/#initialize","text":"Initializes an Agent object and sets the movement speed using the parameter speed . An initialized agent is not pathfinding or moving by default. public void Initialize(float speed) { agent = GetComponent<NavMeshAgent>(); agent.avoidancePriority = Random.Range(30, 60); agent.speed = speed; Pathfinding = false; }","title":"Initialize()"},{"location":"movements/#start","text":"Calls initializer and sets the movement speed of the Agent. private void Start() { Initialize(1.25f); }","title":"Start()"},{"location":"movements/#settarget","text":"Sets the target goal that the Agent will move to. Goal object is set through parameter goal and the Agent destination is mapped to the position of the goal object. The Agent then transitions to an active pathfinding state and will begin to move. The stairs parameter denotes if there are any stairs in the environment, and therefore dictates multi-level movement for the Update() function. public void SetTarget(Transform goal, bool stairs) { this.goal = goal; agent.destination = goal.position; agent.isStopped = false; Pathfinding = true; climbing = stairs; }","title":"SetTarget()"},{"location":"movements/#update","text":"Checks if the target position is reached while the Agent is in an active pathfinding state. Using the x,z coordinates of the goal position and the agent position, we calculate the distance between the two objects. If the distance is less than 0.5 units, we stop the agent's movements and take it out of its active pathfinding state. If there is a multi-level environment as specified in SetTarget(), we incorporate the y value into the distance calculation. With this calculation, if the distance is less than 0.7 units we cease the agent's movements and take it out of its active pathfinding state. private void Update() { if (Pathfinding) { var g = goal.position; var t = transform.position; if (climbing) { var temp = Vector3.Distance(new Vector3(g.x, g.y, g.z), new Vector3(t.x, t.y, t.z)); if (Vector3.Distance(new Vector3(g.x, g.y, g.z), new Vector3(t.x, t.y, t.z)) < 0.7f) { agent.isStopped = true; Pathfinding = false; } } else { if (Vector3.Distance(new Vector3(g.x, 0, g.z), new Vector3(t.x, 0, t.z)) < 0.5f) { agent.isStopped = true; Pathfinding = false; } } } }","title":"Update()"},{"location":"movements/#abort","text":"Stops the Agent and pauses pathfinding efforts. public void abort() { agent.isStopped = true; Pathfinding = false; }","title":"abort()"},{"location":"nav-area/","text":"","title":"Navigation Area"},{"location":"supp-visualization/","text":"","title":"Visualization"},{"location":"unitymodels/","text":"","title":"Unity Models"},{"location":"vis-perception/","text":"","title":"Visual Perception"}]}